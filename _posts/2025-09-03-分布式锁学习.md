---
title: 职位（工作）
author: 刘Sir
date: 2025-08-28 10:10:00 +0800
categories: [技术]
tags: [数据库]
render_with_liquid: false
---

在很多时候面试中，面试官会询问你想了解对方哪些问题，下面我准备询问的问题：
我想深入了解，以便判断自己能否最快地为团队创造价值：
- 想了解一下，这个岗位具体是负责哪一块产品或业务？我是进入一个团队做具体的功能开发，还是独立负责某个模块？
- 团队的开发协作流程是怎样的？比如需求是如何评审的，代码管理和CI/CD流程规范吗？
- 想了解一下团队的工作节奏？一般如何应对项目上线或紧急需求？目前的加班情况如何？
- 这个岗位未来的晋升路径是怎样的？公司是否有技术分享、培训预算或者鼓励学习新技术的机制？
- 公司的绩效考核周期和主要指标是什么？薪资结构里，绩效工资和年终奖的占比大概是多少？


## 分布式锁
分布式锁的延续锁是由程序中的锁（java retranteen lock，go mutex）在多线程下需要控制访问资源的延伸过来的，以前很多是单应用程序内同时访问相同资源加锁互斥就可以解决了，现在是很多应用是分布式微服务架构，应用程序的锁无法满足多实例下共同访问锁的互斥问题。分布式锁需要主要需要解决 **互斥，多个线程（多实例应用本质也是线程）只能有一个可以访问资源**，在实现分布式上面有两种不同的路径，这也是我现在跟着思考获取到的：
- 抢占式，谁抢到锁谁就有执行权（容易造成单个一直获取不到锁）
- 排队式，维护一个锁的列表，先来先执行 （比较公平，但是执行的效率会低点）
这是目前分布式锁上实现的两种方案，
### 数据库实现
建立一个锁表，其中配置一个唯一字段。入库成功则获取锁，然后删除（释放锁）。这种方式优缺点都很明显：
- 简单，无需引入额外的复杂度
- 锁没有过期（容易死锁），没办法续期，性能差
### zookeeper
Zookeeper 是分布式协调组件，天然适合实现分布式锁。它的锁机制主要依赖 临时顺序节点（ephemeral sequential znode） 和 watch 机制。
- 获取锁：所有客户端在某个锁目录下（比如 /lock）创建 临时顺序节点
- 判断是否获取锁：客户端获取到自己节点的序号后，检查自己是不是最小
- 等待锁：没有拿到锁的客户端，会 watch 前一个节点（比如 lock-0002 只 watch lock-0001）
- 释放锁：客户端执行完成后，删除自己的临时节点

所以可以看到 zookeeper 的这个方案有个很大的优势就是公平（先来先获取锁，锁排队）。并且因为节点是客户端临时创建，所以天然防止死锁，当然上面锁上基于顺序锁（公平锁），zookeeper 也可以同时支持抢占式的，把某个路径（比如 /lock/resourceA）直接当作“锁”，谁能成功创建这个节点，谁就持有锁；失败的就说明锁被别人抢占。zookeeper 锁效率低存在的原因：
- 获取锁步骤多：创建节点，读取是否最小，内部一致性（ZAB 协议，强一致性）
- 频繁的节点创建/删除 = 磁盘 & 内存压力


### redis
Redis 的分布式锁（SETNX / SET key value NX PX ttl，再加上 DEL 释放）本质上就是抢占式的，没有像 Zookeeper 那样的“顺序排队”机制，所以它是 非公平锁。


| 特性      | Redis 锁       | Zookeeper 锁     | etcd 锁          | Consul 锁           |
| ------- | ------------- | --------------- | --------------- | ------------------ |
| 锁模型     | 抢占式 (非公平)     | 顺序节点 (公平)       | 基于 lease (相对公平) | Session+KV (非公平)   |
| 一致性     | 弱 (依赖 TTL)    | 强一致             | 强一致 (Raft)      | 一致性依赖 Raft         |
| 性能（QPS） | 极高 (内存)       | 较低 (磁盘+Watcher) | 中等 (Raft 日志写)   | 中等偏低 (gossip+raft) |
| 死锁风险    | 可能有，需 Redlock | 无 (临时节点自动清理)    | 无 (租约自动释放)      | 无 (Session 自动释放)   |
| 适用场景    | 秒杀、热点资源限流     | 分布式调度、主备切换      | 配置中心、任务协调       | 服务治理、配置管理          |

redis 分布式锁的问题：
1. ttl 太长，业务异常未释放锁，导致其他获取不到锁（假死锁）- 合理设置过期时间，或者使用 锁续约机制（
2. ttl 太短，业务未执行完，锁过期，导致其他客户端提前获取锁，这样锁就失效了。
3. 如果 Redis 是单机部署，宕机后锁信息全丢，所有客户端都能重新获取锁 - 锁的持有者发生变化（之前 a 客户端， 宕机重启后是 b 客户端）
4. 客户端成功 setnx + ttl 之后，网络断开 → 业务实际没执行，但其他客户端看不到锁，还在等待。

对于Java开发者来说，直接使用Redisson客户端是避免Redis死锁的最佳选择，因为它帮你封装了所有细节：
- 自动续期：内置看门狗线程，无需关心锁过期。
- 可重入锁：同一个线程可以多次加锁。
- 原子释放：内置Lua脚本，保证释放操作的安全性。
- 多种锁类型：提供公平锁、联锁等多种选择。