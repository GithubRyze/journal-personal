---
title: rabbitmq 学习
author: 刘Sir
date: 2025-08-28 10:10:00 +0800
categories: [技术]
tags: [redis]
render_with_liquid: false
---
## rabbitmq 生产到消费的过程
```
Producer → Exchange → (路由) → Queue → (推送) → Consumer → (ACK) → 删除/重入队列/死信
```
Exchange （只是对消息进行路由，确定消息投放到哪个 queue）
- Direct：按 Routing Key 精确匹配队列绑定键
- Fanout：广播到所有绑定队列
- Topic：按通配符规则匹配（*.order.#）
- Headers：按消息头匹配

Queue （存储消息，可配置持久化）

ACK
- 自动 ACK（autoAck = true）消费者宕机或异常情况下会丢失消息，但是 mq 的吞吐效率高
- 手动 ACK（autoAck = false）消费者确定是否成功，可选择重新入队列/丢弃/死信队列（DLX），会降低 mq 的吞吐，但是可确保消息的可靠性

死信队列（DLX）
消息在某些情况下无法被正常消费，就会变成死信（Dead Letter）。这些死信消息不会直接丢弃，而是按照配置被转发到一个死信交换机（DLX, Dead Letter Exchange），再进入绑定的 死信队列（DLQ），如以下这些情况：
- 消费者消息被拒绝：basic.reject 或 basic.nack），并且 requeue=false
- 消息过期 ttl：消息本身设置了过期时间（expiration 属性），或者队列设置了过期时间（x-message-ttl）。
- 队列达到最大长度限制：x-max-length 或 x-max-length-bytes
使用场景：
- 消息延迟重试：TTL + DLX 组合，实现延时队列
- 消息过期：订单 30 分钟未支付 → 消息过期
- 消息监控 & 告警：监控队列
- 削峰填谷 & 异常隔离：业务队列消费速度跟不上，死信队列可以用来临时“兜底”，防止消息直接丢失

消费模式：
push：push + prefetch，限制每次最多给 Consumer 推送 n 条未确认的消息，防止消费挤压，可实时，效率高
pull：客户端轮询，一次请求只取一条消息，可以控制消费速度

## 重新入队列的消息是在队列的头还是尾
队列头：消费者 NACK / Reject 且 requeue = true，消费者未 ACK 直接断开连接
队列尾：消息 TTL 到期 + DLX 再转回原队列


## 队列堆积
其中主要原因是消费的速度太慢导致的，因此需要从生产和消费，mq 本身的三个方面进行优化。
消费端：
1. 优化代码提升处理能力（异步处理，调整 prefetch 的数量 ）
2. 水平拓展消费的服务
3. 增加消费端的服务硬件配置（内存，cpu 等）
生产端：
1. 限制生产的速度，代码限流
2. 启用生产 Confirm 机制，确保生产者发送消息被 broker 接收后，再继续下一条消息，防止过快堆积。
队列本身：
1. 设置队列的最大容量 （x-max-length / x-max-length-bytes）
2. 配置死性队列，处理失败或者到达队列限制的进入死性队列，兜底
3. 在业务合理拆分队列，试着把大队列看能否拆分小的队列
4. 对队列进行监控和配置告警策略，实时获取队列的指标信息


## mq 的性能
- 纯内存队列单机可达到 几十～百万级别，消息的大小也会影响
- ack，持久化会降低吞吐，1~5 万条/秒，消息大小大、批量消费少、消费慢都会影响性能

提升性能就可以从以下方面入手：
1. 提升硬件配置，内存，cpu，磁盘
2. 尽量使用批处理，批量发送 / 批量 ACK / 批量 Confirm
3. 控制消息的大小
4. 限流/限速
5. 监控和告警

## mq 的消息丢失
RabbitMQ 消息追踪 = 生产端确认 + 消费端确认 + 死信队列 + 唯一消息 ID + 日志/监控

工具：
- Management UI
- rabbitmqctl 命令
- Broker/客户端日志
- Tracing 插件
- Prometheus/Grafana + ELK

## RabbitMQ 集群的几种模式：普通模式、镜像队列、Quorum 队列，有什么区别？
| 方案           | 数据冗余               | 节点故障恢复 | 适用场景          |
| ------------ | ------------------ | ------ | ------------- |
| 集群 Queue     | ❌ 单副本              | ❌      | 高吞吐量，不保证队列 HA |
| 镜像队列         | ✅ Master + Mirrors | ✅ 自动切换 | 队列关键，需高可用     |
| Quorum Queue | ✅ 多副本多数派           | ✅ 自动切换 | 强一致性，高可靠      |

